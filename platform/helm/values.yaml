archestra:
  # The Docker image to use for the Archestra Platform
  # This image contains both the backend API and frontend
  image: archestra/platform:latest

  # Additional environment variables to pass to the container
  # These will be merged with the default DATABASE_URL environment variable
  # Example:
  #   env:
  #     ARCHESTRA_API_BASE_URL: "https://api.example.com"
  #     CUSTOM_VAR: "custom-value"
  env: {}

  # Configuration for the MCP Server Runtime
  orchestrator:
    # Base image for MCP server containers
    # If not set, defaults to "europe-west1-docker.pkg.dev/friendly-path-465518-r6/archestra-public/mcp-server-base:latest"
    baseImage: ""

    # Kubernetes configuration for MCP Server Runtime
    # This controls how the Archestra platform connects to Kubernetes to manage MCP server pods
    kubernetes:
      # Namespace where MCP server pods will be created
      # If not set, defaults to the namespace specified in the helm release
      namespace: ""

      # Kubeconfig configuration
      # Choose one of the following methods:

      # Method 1: Use in-cluster configuration (recommended when running inside K8s)
      # No additional configuration needed - the platform will automatically use the service account
      loadKubeconfigFromCurrentCluster: true

      # Method 2: Mount a kubeconfig file from a secret
      # Set useInClusterConfig to false and configure the secret below
      kubeconfig:
        # Enable kubeconfig volume mount
        enabled: false

        # Name of the secret containing the kubeconfig file
        # The secret should have a key named "config" containing the kubeconfig content
        # Example of creating the secret:
        #   kubectl create secret generic archestra-kubeconfig --from-file=config=/path/to/kubeconfig
        secretName: ""

        # Path where the kubeconfig will be mounted inside the container
        # This will be set as the KUBECONFIG environment variable
        mountPath: /etc/kubeconfig

      # ServiceAccount configuration for the Archestra Platform
      serviceAccount:
        # Specifies whether a service account should be created
        create: true
        # Annotations to add to the service account
        annotations: {}
        # The name of the service account to use.
        # If not set and create is true, a name is generated using the fullname template
        name: ""
        # Image pull secrets to attach to the service account (automatically used by pods)
        # This is the recommended way to configure image pull secrets
        # Example:
        #   imagePullSecrets:
        #     - name: myregistrykey
        imagePullSecrets: []

      # RBAC (Role-Based Access Control) configuration
      rbac:
        # Specifies whether RBAC resources should be created
        create: true

# PostgreSQL configuration
postgresql:
  # External database URL to use instead of deploying a PostgreSQL instance
  # If null, a PostgreSQL instance will be deployed using the Bitnami PostgreSQL chart
  # Example: postgresql://username:password@host:5432/database
  external_database_url: null

  # PostgreSQL subchart configuration (only used when external_database_url is null)
  enabled: true
  auth:
    database: archestra_dev
    username: archestra
    password: archestra_dev_password
  # NOTE: Bitnami is archiving their image.. see these github comments for details
  # (this is essentially why we need to override image.repository and image.tag and global.security.allowInsecureImages)
  #
  # https://github.com/coder/coder/issues/19869#issuecomment-3305875979
  # https://github.com/bitnami/containers/issues/83267
  image:
    repository: bitnamisecure/postgresql
    tag: latest
  global:
    security:
      allowInsecureImages: true
